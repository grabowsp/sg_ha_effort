# Workflow
# Select desired number of SNPs
# Check bp windows by 10 kb, then kb
# Find indices per SNP
# Calculate windows with desired SNPs
# Find window size with highest number of windows

# module load python/3.7-anaconda-2019.07
# source activate local_PCA

library(data.table)
library(lostruct)

### LOAD DATA ###

# VCF info
#data_dir <- '/global/cscratch1/sd/grabowsp/sg_ploidy/polyploid_vcfs/CDS_vcfs/expand_geo_samps/'
data_dir <- '/global/cscratch1/sd/grabowsp/sg_ploidy/polyploid_vcfs/CDS_vcfs/expand_v2/'

chr_name <- 'Chr01K'

vcf_inbetween <- 'polyploid.CDS.expandv2'

vcf_pre <- paste(data_dir, paste(chr_name, vcf_inbetween, 'vcf_', sep = '.'), 
  sep = '')

head_in_short <- 'CDS.expandv2.vcf.header.txt'
vcf_header_file <- paste(data_dir, head_in_short, sep = '')
vcf_header <- gsub('#', '', read.table(vcf_header_file, stringsAsFactors = F,
  sep = '\t', header = F, comment.char = '@'))

# Library info

tet_lib_file <- '/global/cscratch1/sd/grabowsp/sg_ploidy/tetraploid_lib_names_May2020.txt'
tet_libs_0 <- as.vector(read.table(tet_lib_file, header = F,
  stringsAsFactors = F)[,1])
tet_libs <- intersect(tet_libs_0, vcf_header)

oct_lib_file <- '/global/cscratch1/sd/grabowsp/sg_ploidy/octoploid_lib_names_May2020.txt'
oct_libs_0 <- as.vector(read.table(oct_lib_file, header = F,
  stringsAsFactors = F)[,1])
oct_libs <- intersect(oct_libs_0, vcf_header)

remove_lib_file <- '/global/cscratch1/sd/grabowsp/sg_ploidy/local_pca_remove_samps_09152020.txt'
remove_libs <- as.vector(read.table(remove_lib_file, header = F,
  stringsAsFactors = F)[,1])

#######
# FUNCTIONS #
process_vcf <- function(vcf, oct_libs, tet_libs, rm_libs){
  # Processes VCF to generate matrix with dosage genotypes appropriate
  #   for each ploidy level
  # INPUTS
  # vcf = vcf data.frame file with header
  # oct_libs = vector of names of octoploid libraries
  # tet_libs = vector of names of tetraploid libraries
  # rm_libs = vector of names of libraries to remove
  # OUTPUT
  # matrix of ALT dosage genotypes ranging from 0 to 2; 
  #  rows = SNPS, columns = samples; 
  #######################
  oct_df <- vcf[, setdiff(oct_libs, rm_libs)]
  tet_df <- vcf[, setdiff(tet_libs, rm_libs)]
  #
  oct_df[oct_df == './.'] <- NA
  tet_df[tet_df == './.'] <- NA
  #
  geno_vec <- c('4/0', '3/1', '2/2', '1/3', '0/4')
  oct_dosage_vec <- c('0', '0.5', '1', '1.5', '2')
  tet_dosage_vec <- c('0', '1', '1', '1', '2')
  #
  for(i in seq(length(geno_vec))){
    oct_df[oct_df == geno_vec[i]] <- oct_dosage_vec[i]
  }
  for(i in seq(length(geno_vec))){
    tet_df[tet_df == geno_vec[i]] <- tet_dosage_vec[i]
  }
  for(i in seq(ncol(oct_df))){
    oct_df[, i] <- as.numeric(oct_df[, i])
  }
  for(i in seq(ncol(tet_df))){
    tet_df[, i] <- as.numeric(tet_df[, i])
  }
  geno_df <- cbind(oct_df, tet_df)
  geno_mat <- matrix(unlist(geno_df), ncol = ncol(geno_df),
    byrow = F)
  rownames(geno_mat) <- seq(nrow(geno_mat))
  colnames(geno_mat) <- colnames(geno_df)
  return(geno_mat)
}

###

get_window_inds <- function(vcf, min_pos, max_pos, bp_win_size){
  # Get the indices for each SNP in a window
  # INPUTS
  # vcf = vcf data.frame with header;
  # min_pos = lowest position; where to start with making bp-based windows
  # max_pos = highest position; where to stop making windows
  # bp_win_size = the bp window size; ex: 5e5
  # OUTPUT
  # List with two elements
  # 'window_start_pos' = vector of the the starting position for each window
  # 'bp_window_list' <- list with each element containing the SNP indices
  #                       found in that corresponding window. For windows
  #                       that contain no SNPs, the element will be empty
  ################
  bp_start_pos <- seq(min_pos, max_pos, by = bp_win_size)
  bp_end_pos <- c((bp_start_pos[-1] - 1), max_pos)
  # Get snp indieces for each window
  bp_window_list <- list()
  #
  for(i in seq(length(bp_start_pos))){
    tmp_inds <- which(vcf$POS >= bp_start_pos[i] &
      vcf$POS < bp_end_pos[i])
    bp_window_list[[i]] <- tmp_inds
  }
  last_start_pos <- rev(bp_start_pos)[1]
  out_list <- list()
  out_list[['window_start_pos']] <- bp_start_pos
  out_list[['bp_window_list']] <- bp_window_list
  return(out_list)
}

###

get_subsamp_window_inds <- function(bp_window_list, snp_win_size){
  # Subsample the SNP indices within windows so that all windows have
  #   the same number of SNPs
  # INPUTS
  # bp_window_list = list of SNP indices in each window; is out_list[[2]]
  #                   generated by get_window_inds()
  # snp_win_size = the number of SNPs to include in each window; ex: 1000
  # OUTPUT
  # vector of indices for the snps that should be used for the analysis
  #   these indices are used to select from the VCF and geno_mat objects
  ################
  nsnps_per_wind <- unlist(lapply(bp_window_list, length))
  good_windows <- which(nsnps_per_wind >= snp_win_size)
  #
  bp_sub_window_list <- list()
  for(j in seq(length(good_windows))){
    tmp_wind_inds <- bp_window_list[[good_windows[j]]]
    sub_inds <- sort(sample(tmp_wind_inds, size = snp_win_size))
    bp_sub_window_list[[j]] <- sub_inds
  }
  #
  good_sub_snp_inds <- unlist(bp_sub_window_list)
  return(good_sub_snp_inds)
}

########

eigen_window_fixNAs <- function(test_mat, win_size, test_k, fna.verbose = F){
  # run eigen_windows() and replace NA's in the genotype matrix if they
  #  are causing NA's in the output from eigenwindows
  # INPUTS
  # test_mat = genotype matrix used for eigen_windows()
  # win_size = number of SNPs in windows
  # test_k = k to test for PCA
  # fna.verbose = if T, then prints the problematic windows and windows that 
  #                  are getting fixed at the moment
  # OUTPUT
  # output from eigen_windows() with no NAs
  ############
  win_start <- seq(1, nrow(test_mat), win_size)
  win_end <- unique(c(seq(win_size, nrow(test_mat), win_size), nrow(test_mat)))
  tmp_ew <- eigen_windows(data = test_mat, k = test_k, win = win_size)
  prob_windows <- which(is.na(tmp_ew[,1]))
  if(fna.verbose){print(prob_windows)}
  if(length(prob_windows > 0)){
    while(length(prob_windows) > 0){
      for(pw in prob_windows){
        if(fna.verbose){print(pw)}
        test_cov <- cov(sweep(test_mat[c(win_start[pw]:win_end[pw]), ], 1, 
          rowMeans(test_mat[c(win_start[pw]:win_end[pw]), ],
          na.rm = T), "-"), use = "pairwise")
        test_cov_nas <- which(is.na(test_cov), arr.ind = T)
        test_cov_prob_inds <- c(test_cov_nas[,1], test_cov_nas[,2])
        test_cov_prob_tab <- table(test_cov_prob_inds)
        test_prob_inds <- as.numeric(names(
          which(test_cov_prob_tab >= mean(test_cov_prob_tab))))
        #
        tmp_rM <- rowMeans(test_mat[c(win_start[pw]:win_end[pw]), ], na.rm = T)
        for(tpi in test_prob_inds){
          tmp_prob_snps <- which(is.na(
            test_mat[c(win_start[pw]:win_end[pw]), tpi]))
          tmp_snps_tochange <- sort(sample(tmp_prob_snps, 
            length(tmp_prob_snps)/2))
          test_mat[c(win_start[pw]:win_end[pw])[tmp_snps_tochange], 
            tpi] <- tmp_rM[tmp_snps_tochange]
        }
      }
      tmp_ew <- eigen_windows(data = test_mat, k = 2, win = win_size)
      prob_windows <- which(is.na(tmp_ew[,1]))
      if(fna.verbose){print(prob_windows)}
    }
  }
  return(tmp_ew)
}


#############

sys_com <- paste('ls ', vcf_pre, '*', sep = '')
vcf_files <- system(sys_com, intern = T)

#vcf_in <- vcf_files[1]

# Choose best window size

snp_win_size <- 1000
wind_interval <- 1e4
max_wind_size <- 1e6
test_window_sizes <- seq(from = wind_interval, to = max_wind_size,
  by = wind_interval)

# vf <- 1

window_test_list <- list()

for(vf in seq(length(vcf_files))){
  print(paste('vcf subfile ', vf, sep = ''))
  vcf_in <- vcf_files[vf]
  vcf <- read.table(vcf_in, header = F, stringsAsFactors = F, sep = '\t')
  colnames(vcf) <- vcf_header
  #
  geno_mat_1 <- process_vcf(vcf = vcf, oct_libs = oct_libs, tet_libs = tet_libs,
    rm_libs = remove_libs)
  genomat_ngenos <- apply(geno_mat_1, 1,
    function(x) length(setdiff(unique(x), NA)))
  invar_loci <- which(genomat_ngenos == 1)
  geno_mat_1_filt <- geno_mat_1[-invar_loci, ]
  vcf_1_filt <- vcf[-invar_loci, ]
  #### Look at the bp sizes for the desired number of SNPs
  n_good_vec <- c()
  tot_pos_wind_vec <- c()
  for(i in test_window_sizes){
    test_wind_snps <- get_window_inds(vcf = vcf_1_filt, 
      min_pos = min(vcf_1_filt$POS), max_pos = max(vcf_1_filt$POS), 
      bp_win_size = i)
    n_good_winds <- length(which(unlist(
      lapply(test_wind_snps[[2]], length)) >= snp_win_size))
    n_good_vec <- c(n_good_vec, n_good_winds)
    tot_pos_wind_vec <- c(tot_pos_wind_vec, length(test_wind_snps[[2]]))
  }
  max_good_wind_size <- test_window_sizes[which.max(n_good_vec)]
  good_wind_n <- max(n_good_vec)
  per_max_good_wind <- good_wind_n/tot_pos_wind_vec[which.max(n_good_vec)]
  window_test_list[[vf]] <- list()
  window_test_list[[vf]][['best_window']] <- max_good_wind_size
  window_test_list[[vf]][['n_good_windows']] <- good_wind_n
  window_test_list[[vf]][['per_good_windows']] <- per_max_good_wind
}


mean_best_window <- mean(unlist(
  lapply(window_test_list, function(x) x[['best_window']])))
# 74545.45

median_best_window <- median(unlist(
  lapply(window_test_list, function(x) x[['best_window']])))
# [1] 70000

median_per_good_wind <- median(unlist(
  lapply(window_test_list, function(x) x[['per_good_windows']])))
# 0.6

# How does chosen window size fit across genome

chosen_window <- median_best_window

chosen_window_list <- list()

for(vf in seq(length(vcf_files))){
  print(paste('vcf subfile ', vf, sep = ''))
  vcf_in <- vcf_files[vf]
  vcf <- read.table(vcf_in, header = F, stringsAsFactors = F, sep = '\t')
  colnames(vcf) <- vcf_header
  #
  geno_mat_1 <- process_vcf(vcf = vcf, oct_libs = oct_libs, tet_libs = tet_libs,
    rm_libs = remove_libs)
  genomat_ngenos <- apply(geno_mat_1, 1,
    function(x) length(setdiff(unique(x), NA)))
  invar_loci <- which(genomat_ngenos == 1)
  geno_mat_1_filt <- geno_mat_1[-invar_loci, ]
  vcf_1_filt <- vcf[-invar_loci, ]
  #### Look at the bp sizes for the desired number of SNPs

  test_wind_snps <- get_window_inds(vcf = vcf_1_filt,
    min_pos = min(vcf_1_filt$POS), max_pos = max(vcf_1_filt$POS),
    bp_win_size = chosen_window)
  n_good_winds <- length(which(unlist(
    lapply(test_wind_snps[[2]], length)) >= snp_win_size))
  per_good_winds <- n_good_winds/length(test_wind_snps[[2]])

  chosen_window_list[[vf]] <- list()
  chosen_window_list[[vf]][['n_good_windows']] <- n_good_winds
  chosen_window_list[[vf]][['per_good_windows']] <- per_good_winds
}

chosen_good_window_vec <- unlist(lapply(chosen_window_list, 
  function(x) x[['n_good_windows']]))
total_good_windows <- sum(chosen_good_window_vec)
# 403

per_good_window_vec <- unlist(lapply(chosen_window_list,
  function(x) x[['per_good_windows']]))

tot_window_vec <- chosen_good_window_vec/per_good_window_vec

total_potential_windows <- sum(tot_window_vec)
#814

total_percent_good_windows <- total_good_windows/total_potential_windows
# 0.495086

# When using 70k bp windows, only include 50% of the windows across Chr01K


